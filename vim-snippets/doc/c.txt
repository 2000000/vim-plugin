*c.txt*

cbase                                                                  *c-base*
char * const s;
const char * s;
char const * s;

Reserved words                                              *c-reserve* *c-res*
C89(32):
unsigned  return  while  auto  int
register  signed  union  case  for
continue  sizeof  break  enum  if
volatile  double  short  long  do
          switch  const  goto
default   struct         else
typedef   extern         char
          static         void

C99(+5):
_Bool _Complex  _Imaginary inline restrict


C++ 11 (73):
alignas		continue		friend		register			true
alignof		decltype		goto		reinterpret_cast	try
asm			default			if			return				typedef
auto		delete			inline		short				typeid
bool		do				int			signed				typename
break		double			long		sizeof				union
case		dynamic_cast	mutable		static				unsigned
catch		else			namespace	static_assert		using
char		enum			new			static_cast			virtual
char16_t	explicit		noexcept	struct				void
char32_t	export			nullptr		switch				volatile
class		extern			operator	template			wchar_t
const		false			private		this				while
constexpr	float			protected	thread_local
const_cast	for				public		throw


Operator precedence            Associativity               *c-operator* *c-ope*
-----------------------------------------------
() [] -> .
! ~ ++ -- - (type) * & sizeof	right to left
* / %
+ -
<< >>
< <= > >=
== !=
&
^
|
&&
||
?:                              right to left
= += -= etc.                    right to left
, comma operator[wikipedia]

classification:
arithmetic: +, -, *, /, %
assignment: = += -= etc.
bitwise logic: ~, &, |, ^
bitwise shifts: <<, >>
boolean logic: !, &&, ||
conditional evaluation: ? :
equality testing: ==, !=
increment and decrement: ++, --
order relations: <, <=, >, >=

c99 std lib <24>                                                        *c-lib*
C:   /usr/include/
C++: /usr/include/c++ <cassert>
<assert.h>  <complex.h>  <ctype.h>     <errno.h>
<fenv.h>    <float.h>    <inttypes.h>  <iso646.h>
<limits.h>  <locale.h>   <math.h>      <setjmp.h>
<signal.h>  <stdarg.h>   <stdbool.h>   <stddef.h>
<stdint.h>  <stdio.h>    <stdlib.h>    <string.h>
<tgmath.h>  <time.h>     <wchar.h>     <wctype.h>

Postfix Increment Operator                                *c-increment* *c-inc*
*s++; // *(s++);
*++s;
(*s)++;
++*s;

a=2+i++;
i++; //  ++i;

C99 P67
i = ++i + 1; a[i++] = i; //the behavior is undefined
i+++i; i+i++;

                                                          *cpp-base*
#include <stdio.h>
#include <iostream>
using namespace std;

// 16.8 Predefined macro names
#if defined __cplusplus
#endif

int a(5)；即 int a=5; 用构造函数构造初始化类，如classA a(b);

<<C++ Coding Standards: 101 Rules, Guidelines, and Best Practices>>

增加 .*  ->*
C++将前++/-- 和后++/-- 分为不同优先级
C++ 前++/-- 定为第一有限级，跟. [] () 同级，C没有这种情况

boost (libboost-dev)

www.open-std.org
libcxx.llvm.org/
libc++ is a new implementation of the C++ standard library, targeting C++11.

C++11: ISO/IEC 14882:2011 Information technology-Programming languages C++

In addition to the facilities provided by C, C ++ provides additional data types, 
classes, templates, exceptions, namespaces,
operator overloading, function name overloading, references, free store management 
operators, and additional library facilities.

1 类中类，结构体中结构体
2 含纯虚函数的类是抽象基类
3 gcc/g++识别c++: .C/.cc(C with classes)/.cpp(C plus plus)/.CPP/.c++/.cp/.cxx
4 non-const references can't bind temp objects.  Foo &obj = Foo(); //vs ok,gcc fail

C++11:
7.3
Namespaces

标准头文件位置：
/usr/include/c++/4.8/ostream
文件头注释：
forwarding header (转接头文件)
GNU ISO C++ Library
ISO C++ 14882: 27.8.2  C Library files

const_cast<>
reinterpret_cast<>
dynamic_cast<>
static_cast<> 类型转换
用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。进行上行转换
（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基
类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。

cout /cin 字符输出
endl end line

static const

static final Singleton<IActivityManager> gDefault = 
static const int COUNT=5;

static inline int foo(void)
{
}

int main(void)
{
	cout << "Hello World!"<<endl;

	printf("i=%d\n", i);
	return 1;
}

种继承方式：私有成员都变不可用
公有继承，公有保护保持原样，保护继承公有保护全保护，私有继承公有保护全私有。
不派生时，保护与私有的地位一致，类外都无法访问，但保护成员可以被派生类的成员函数引用。
Java继承不分共有私有保护，简化了继承关系处理，但也能解决实际问题

                                                         *m-base*
3.4.2 Special Parameters
10.5.3 Automatic Variables
predefined variables:
CFLAGS
CXXFLAGS
LDFLAGS
LDLIBS(make文档未提及，实测是)
$(foreach var, list, text)
$(filter pattern...,text)
test:=$(wordlist 3,5, 1 2 3 4 5 6 7 8 9)

DATE:=$(shell date)
DATE:=`date` # 可用但make文档中没找到官方说明

4.10 Multiple Targets in a Rule 
4.11 Multiple Rules for One Target
= recursively expanded  := simply expanded  ?=
$x单字母变量
变量后的空格会保留
Pattern Rules
%.o:%.cpp
	$(CC) $(CPPFLAGS) -c -o $@ $<
foo.o : foo.c defs.h
	cc -c -g foo.c
	
默认规则
all: foo
执行显示：
cc foo.c -o foo

A blank line that begins with a tab is not blank: it's an empty command

6.3.1 Substitution References
递归3法：make -C dir / -f file /include
-include：文件不存在时不提示错误

#4.7 Rules without Commands or(and更恰当吧) Prerequisites
#If a rule has no prerequisites or commands, and the target of the rule is a nonexistent file, 
#then make imagines this target to have been updated whenever its rule is run. 
#This implies that all targets depending on this one will always have their commands run. 
#不严密 如果存在FORCE和all文件，且all新于FORCE，照样不执行
#没有FORCE文件或旧于all,可以执行
foo: FORCE
	@echo Hello

FORCE:

bar:
	@echo World

#特殊逻辑，只有强记
.PHONY: bar

#android里的一个用法
.PHONY: FORCE
%.pem: $(DSAPARAM) FORCE

ifndef SHOW
.SILENT:
endif

define first-makefiles-under
$(shell findleaves.py --mindepth=2 $(1) Android.mk)
endef

all:
	gcc ff-test.c -o ff-test -lfftw3 -lm 
	
phony target
2种方式  
1) 没有Commands和Prerequisites的Rules，习惯 FORCE:
2) Special Built-in Target .PHONY (vi黄色)

模板目标，属于隐式规则
在命令区域定义变量，不是make变量是shell变量
之前考虑函数能否在target的command部分，其实随便，扩展出来的东西是命令就能放，
扩展出来不是命令，执行就错误

又如：
$(info text...) 返回空，所以可写在任何地方没影响
2种基本形式：1 定义变量； 2 rule

因为先展开再执行，展开阶段就把函数$(info ...)执行了，它在控制台输出了World!，
返回了null，这行是empty command
函数调用 resembles a variable reference:
$(function arguments) 或 ${function arguments}
cc -MM test.cpp可生成cpp的.o的依赖关系

8.12 控制Make的函数
System types:
  --build=BUILD     configure for building on BUILD [guessed]
  --host=HOST       cross-compile to build programs to run on HOST [BUILD]

1) If you meant to cross compile, use `--host'.

vim: tw=80
